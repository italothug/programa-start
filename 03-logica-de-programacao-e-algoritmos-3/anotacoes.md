# Aula 01 - Boas Vindas

## Comandos
- ``System.out.println();`` = ``Escreval()`` do Portugol
- ``// Comentário de linha``
- ``/* Comentário de bloco */``
- ``/** Comentário de documentação */``
  - É um comentário que sai expresso em um papel, comentário usado muitas vezes em empresas com outras pessoas que precisam ler seu código.
- ``import java.util.Scanner;`` 
  - Leitor / Comando de entrada e saida do **JAVA**
- ``Scanner leitor = new Scanner(System.in);``
  - Forma de criar um leitor para dentro do **JAVA**
- ``var nome = leitor.nextVar();`` = ``Leia`` do Portugol
  - Forma de ler o próximo dado que se encaixaria naquela variavel
- Tipos de ``Var``
  - `int` 
    - Variavel de número INTEIRO
  - ``float`` e ``double`` 
    - Variaveis de número REAL
    - Diferença:
      - O double tem mais precisão: pode representar mais casas decimais ou números inteiros maiores;
      - O double ocupa 32 bits a mais que o float (o dobro do espaço);
      - Dependendo do hardware, o cálculo de um ou outro será mais rápido. Placas de vídeo geralmente operam com floats, as mais novas, com doubles.

## 1.A

Só explicações sobre o professor

# Aula 02 - Apresentação do Conteúdo

## 2.A

- 1. Introdução ao treinamento e plano de ensino

- 2. Linguagem JAVA
  - 2.1. Conhecendo sua ferramenta de desenvolvimento (NETBEANS)
  - 2.2. Diferenças entre Portugol e o JAVA
  - 2.3. Comntarios
  - 2.4. Comandos de entrada e saída
  - 2.5. Variaveis, tipos e operadores
  - 2.6. Estruturas condicionais
    - 2.6.1. Estrutura if
    - 2.6.2. Estrutura switch
    - 2.6.3. Exercicios estruturas condicionais I
    - 2.6.4. Exercicios estruturas condicionais II
  - 2.7. Estruturas de repetição
    - 2.7.1. Estruture while
    - 2.7.2. Estruture for
    - 2.7.3. Exercicios estruturas de repetição I
    - 2.7.4. Exercicios estruturas de repetição II
    - 2.7.5. Exercicios estruturas de repetição III
  - 2.8. Orientação a Objetos
  - 2.9. Classes
  - 2.10. Métodos
  - 2.11. Objetos
  - 2.12. Modificadores de acesso
  - 2.13. Métodos construtores
  - 2.14. Herança (Parte I)
  - 2.15. Herança (Parte II)
  - 2.16. Herança (Parte III)
  - 2.17. Exercícios JAVA
  - 2.18. Exercícios JAVA
  - 2.19. Exercícios 00
  - 2.20. Exercícios 00
- 3. Interfaces gráficas utilizando o SWING
  - 3.1. Criando uma tela
  - 3.2. Paleta de Componentes
    - 3.2.1. Componentes
    - 3.2.2. Propriedades
    - 3.2.3. Eventos (Programação orientada a eventos)
  - 3.3. Arvore de componentes
  - 3.4. Detalhes importantes
  - 3.5. Exercicios (criação de uma tela de login)
  - 3.6. Exercicios (criação de uma tela de login)
  - 3.7. Exercicios (criação de uma tela de login)
- 4. Iniciando um projeto
  - 4.1. Definição de um projeto básico
    - 4.1.1. Requisitos do projeto
    - 4.1.2. Regras de negócio
    - 4.1.3. Definição da tecnologia
- 5. Especificando o Projeto
  - 5.1. Criando o banco de dados e as tabelas da aplicação (Parte I)
  - 5.2. Criando o banco de dados e as tabelas da aplicação (Parte II)
  - 5.3. Prototipo de interface
- 6. Iniciando a codificação
  - 6.1. Finalizando a criação das classes do modelo
  - 6.2. Criação da conexão com o Banco de Dados
    - 6.2.1. Criação da conexão com o Banco de Dados I
    - 6.2.2. Criação da conexão com o Banco de Dados II
    - 6.2.3. Criação da conexão com o Banco de Dados III
    - 6.2.4. Criação da conexão com o Banco de Dados IV
  - 6.3. Criação dos controladores (Ponte entre aplicação e o banco de dados)
    - 6.3.1. Criação dos controladores I 
    - 6.3.2. Criação dos controladores II
    - 6.3.3. Criação dos controladores III
    - 6.3.4. Criação dos controladores IV
    - 6.3.5. Criação dos controladores V
    - 6.3.6. Criação dos controladores VI
    - 6.3.7. Criação dos controladores VII
    - 6.3.8. Criação dos controladores VIII
    - 6.3.9. Criação dos controladores IX
    - 6.3.10. Criação dos controladores X
    - 6.3.11. Criação dos controladores XI
    - 6.3.12. Criação dos controladores XII
  - 6.4. Construção da interface gráfica
    - 6.4.1. Construção da interface gráfica I
    - 6.4.2. Construção da interface gráfica II
    - 6.4.3. Construção da interface gráfica III
    - 6.4.4. Construção da interface gráfica IV
    - 6.4.5. Construção da interface gráfica V
    - 6.4.6. Construção da interface gráfica VI
    - 6.4.7. Construção da interface gráfica VII
    - 6.4.8. Construção da interface gráfica VIII
    - 6.4.9. Construção da interface gráfica IX
    - 6.4.10. Construção da interface gráfica X
  - 6.5. Implementando a tela de cadastro de Projeto
    - 6.5.1. Implementando a tela de cadastro de Projeto I
    - 6.5.2. Implementando a tela de cadastro de Projeto II
    - 6.5.3. Implementando a tela de cadastro de Tarefa I
    - 6.5.4. Implementando a tela de cadastro de Tarefa II
    - 6.5.5. Implementando a tela de cadastro de Tarefa III
  - 6.6. Carregando a lista de Projetos
    - 6.6.1. Carregando a lista de Projetos I
    - 6.6.2. Carregando a lista de Projetos II
    - 6.6.3. Carregando a lista de Projetos III
    - 6.6.4. Carregando a lista de Projetos IV
  - 6.7. Implementando o model da lista de tarefas
    - 6.7.1. Implementando o model da lista de tarefas I
    - 6.7.2. Implementando o model da lista de tarefas II
    - 6.7.3. Implementando o model da lista de tarefas III
    - 6.7.4. Implementando o model da lista de tarefas IV
    - 6.7.5. Implementando o model da lista de tarefas V
    - 6.7.6. Implementando o model da lista de tarefas VI
    - 6.7.7. Implementando o model da lista de tarefas VII
    - 6.7.8. Implementando o model da lista de tarefas VIII
    - 6.7.9. Implementando o model da lista de tarefas IX
  - 6.8. Finalizando as funcionalidades básicas
    - 6.8.1. Finalizando as funcionalidades básicas I
    - 6.8.2. Finalizando as funcionalidades básicas II
    - 6.8.3. Finalizando as funcionalidades básicas III
    - 6.8.4. Finalizando as funcionalidades básicas IV
    - 6.8.5. Finalizando as funcionalidades básicas V
    - 6.8.6. Finalizando as funcionalidades básicas VI
    - 6.8.7. Finalizando as funcionalidades básicas VII
    - 6.8.8. Finalizando as funcionalidades básicas VIII
    - 6.8.9. Finalizando as funcionalidades básicas IX
  - 6.9. Customizações da interface
    - 6.9.1. Customizações da interface I
    - 6.9.2. Customizações da interface II
    - 6.9.3. Customizações da interface III
    - 6.9.4. Customizações da interface IV
    - 6.9.5. Customizações da interface V
  - 6.10. Validações
    - 6.10.1. Validações I
    - 6.10.2. Validações II
  - 6.11. Alternativas de implementação
    - 6.11.1. Alternativas de implementação I
    - 6.11.2. Alternativas de implementação II
  - 6.12. Rodando a aplicação em modo debug
  - 6.13. Resultado obtido e considerações finais

# Aula 03 - Instalação de Ferramentas

## 3.A

[Kit](https://www.oracle.com/java/technologies/downloads/#jdk18-windows) de desenvolvimento JAVA

[Netbeans](https://netbeans.apache.org//)

[XAMPP](https://www.apachefriends.org/pt_br/download.html)

# Aula 04 - A Linguagem em Java

## 4.A

ByteCode: 
- Código intermediario 
- É um código que é gerado após o projeto ser compilado
- Ele é executado por uma JVM(JRE)

## 4.B

Apresentando o NetBeans

## 4.C

Gerenciadores de dependência
- Maven
- Grandle
- Ant

Metodo [``main``](./imagens/metodo-main.png):

Ponto de partida de execução do algoritmo, equivalente ao ``inicio`` e ``fim`` do **Portugol**

- ``System.out.println();`` = ``Escreval()`` do Portugol

[First-code](./imagens/first-code.png)

## 4.D

Comentários em JAVA

- ``// Comentário de linha``
- ``/* Comentário de bloco */``
- ``/** Comentário de documentação */``

## 4.E

Comandos de leitura e gravação

O ``Java`` não possui um _leitor / comando de entrada e saída_, então sabendo disso, há a possibilidade de adicionar o ``Scanner``, que é um recurso externo

- ``import java.util.Scanner;`` = Leitor / Comando de entrada e saida do JAVA
- ``Scanner leitor = new Scanner(System.in);`` = Forma de criar um leitor para dentro do **JAVA**
- ``var nome = leitor.nextVar();`` = ``Leia`` do Portugol
  - Forma de ler o próximo dado que se encaixaria naquela variavel
- Tipos de ``Var``
  - `int` 
    - Variavel de número INTEIRO
  - ``float`` e ``double`` 
    - Variaveis de número REAL
    - Diferença:
      - O double tem mais precisão: pode representar mais casas decimais ou números inteiros maiores;
      - O double ocupa 32 bits a mais que o float (o dobro do espaço);
      - Dependendo do hardware, o cálculo de um ou outro será mais rápido. Placas de vídeo geralmente operam com floats, as mais novas, com doubles.

Exemplo de uso dos comandos de _entrada_ e _saída_ // ``Leia`` e ``Escreval``

[Exemplo-1](./imagens/aula4-ex1.png)